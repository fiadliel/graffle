var e,t,n;new Set(Object.keys({Name:[],Document:["definitions"],OperationDefinition:["name","variableDefinitions","directives","selectionSet"],VariableDefinition:["variable","type","defaultValue","directives"],Variable:["name"],SelectionSet:["selections"],Field:["alias","name","arguments","directives","selectionSet"],Argument:["name","value"],FragmentSpread:["name","directives"],InlineFragment:["typeCondition","directives","selectionSet"],FragmentDefinition:["name","variableDefinitions","typeCondition","directives","selectionSet"],IntValue:[],FloatValue:[],StringValue:[],BooleanValue:[],NullValue:[],EnumValue:[],ListValue:["values"],ObjectValue:["fields"],ObjectField:["name","value"],Directive:["name","arguments"],NamedType:["name"],ListType:["type"],NonNullType:["type"],SchemaDefinition:["description","directives","operationTypes"],OperationTypeDefinition:["type"],ScalarTypeDefinition:["description","name","directives"],ObjectTypeDefinition:["description","name","interfaces","directives","fields"],FieldDefinition:["description","name","arguments","type","directives"],InputValueDefinition:["description","name","type","defaultValue","directives"],InterfaceTypeDefinition:["description","name","interfaces","directives","fields"],UnionTypeDefinition:["description","name","directives","types"],EnumTypeDefinition:["description","name","directives","values"],EnumValueDefinition:["description","name","directives"],InputObjectTypeDefinition:["description","name","directives","fields"],DirectiveDefinition:["description","name","arguments","locations"],SchemaExtension:["directives","operationTypes"],ScalarTypeExtension:["name","directives"],ObjectTypeExtension:["name","interfaces","directives","fields"],InterfaceTypeExtension:["name","interfaces","directives","fields"],UnionTypeExtension:["name","directives","types"],EnumTypeExtension:["name","directives","values"],InputObjectTypeExtension:["name","directives","fields"]})),(n=e||(e={})).QUERY="query",n.MUTATION="mutation",n.SUBSCRIPTION="subscription",function(e){e.NAME="Name",e.DOCUMENT="Document",e.OPERATION_DEFINITION="OperationDefinition",e.VARIABLE_DEFINITION="VariableDefinition",e.SELECTION_SET="SelectionSet",e.FIELD="Field",e.ARGUMENT="Argument",e.FRAGMENT_SPREAD="FragmentSpread",e.INLINE_FRAGMENT="InlineFragment",e.FRAGMENT_DEFINITION="FragmentDefinition",e.VARIABLE="Variable",e.INT="IntValue",e.FLOAT="FloatValue",e.STRING="StringValue",e.BOOLEAN="BooleanValue",e.NULL="NullValue",e.ENUM="EnumValue",e.LIST="ListValue",e.OBJECT="ObjectValue",e.OBJECT_FIELD="ObjectField",e.DIRECTIVE="Directive",e.NAMED_TYPE="NamedType",e.LIST_TYPE="ListType",e.NON_NULL_TYPE="NonNullType",e.SCHEMA_DEFINITION="SchemaDefinition",e.OPERATION_TYPE_DEFINITION="OperationTypeDefinition",e.SCALAR_TYPE_DEFINITION="ScalarTypeDefinition",e.OBJECT_TYPE_DEFINITION="ObjectTypeDefinition",e.FIELD_DEFINITION="FieldDefinition",e.INPUT_VALUE_DEFINITION="InputValueDefinition",e.INTERFACE_TYPE_DEFINITION="InterfaceTypeDefinition",e.UNION_TYPE_DEFINITION="UnionTypeDefinition",e.ENUM_TYPE_DEFINITION="EnumTypeDefinition",e.ENUM_VALUE_DEFINITION="EnumValueDefinition",e.INPUT_OBJECT_TYPE_DEFINITION="InputObjectTypeDefinition",e.DIRECTIVE_DEFINITION="DirectiveDefinition",e.SCHEMA_EXTENSION="SchemaExtension",e.SCALAR_TYPE_EXTENSION="ScalarTypeExtension",e.OBJECT_TYPE_EXTENSION="ObjectTypeExtension",e.INTERFACE_TYPE_EXTENSION="InterfaceTypeExtension",e.UNION_TYPE_EXTENSION="UnionTypeExtension",e.ENUM_TYPE_EXTENSION="EnumTypeExtension",e.INPUT_OBJECT_TYPE_EXTENSION="InputObjectTypeExtension"}(t||(t={}));const r=e=>e instanceof Error?e:Error(e+""),o=e=>{throw Error("Unhandled case: "+e)},i=e=>{let t,n,r=!1;return{promise:new Promise(((e,r)=>{t=e,n=r})),isResolved:()=>r,resolve:n=>{if(r=!0,e?.strict&&r)throw Error("Deferred is already resolved. Attempted to resolve with: "+JSON.stringify(n));t(n)},reject:e=>n(e)}},a=(...e)=>{process.env.DEBUG&&console.log(...e)},s=(...e)=>(...t)=>{a(...e,...t)},u=(e,t,n=[])=>new Proxy(e,{get:(e,r,o)=>{const i=Reflect.get(e,r,o);return"_"===r&&0===n.length?i:(e=>"object"==typeof e&&null!==e&&!Array.isArray(e))(i)?u(i,t,[...n,r]):t({property:r,path:n})??Reflect.get(e,r,o)}});new Proxy({},{get:()=>e=>e});const c=e=>"string"==typeof e,l=e=>null!==e,p=e=>e;class d extends Error{context;cause;name="ContextualError";constructor(e,t={},n=void 0){super(e,n),this.context=t,this.cause=n}}class m extends d{errors;name="ContextualAggregateError";constructor(e,t,n){super(e,t,void 0),this.errors=n}}const f=(e,t)=>"default"===e.errors[t]?e.defaults.errorChannel:e.errors[t],h={defaults:{errorChannel:"throw"},envelope:{enabled:!1,errors:{execution:!0,other:!1}},errors:{execution:"default",other:"default"}},v=(e,t)=>{if((n=e.output).envelope.enabled&&n.envelope.errors.execution&&!n.envelope.errors.other){if(t instanceof Error)throw t;return t.value}var n;const r=e.output,o=r.envelope.enabled,i=!("throw"!==f(r,"other")||r.envelope.enabled&&r.envelope.errors.other),a=!("return"!==f(r,"other")||r.envelope.enabled&&r.envelope.errors.other),s=!("throw"!==f(r,"execution")||r.envelope.enabled&&r.envelope.errors.execution),u=!("return"!==f(r,"execution")||r.envelope.enabled&&r.envelope.errors.execution);if(t instanceof Error){if(i)throw t;return a?t:o?{errors:[t]}:t}if(t.value.errors&&t.value.errors.length>0){const e=new m("One or more errors in the execution result.",{},t.value.errors.map((e=>{if(e instanceof Error)return e;const{message:t,...n}=e;return new d(t,n)})));if(s)throw e;return u?e:o?{...t.value,errors:[...t.value.errors??[],e]}:e}return o?t.value:t.value.data},y=e=>{const t={discriminant:e.discriminant,inputDefaults:e.inputDefaults,steps:{}},n={type:t,config:()=>n,defaults:e=>(t.inputDefaults=e,n),configInit:()=>n,stepWithExtendedInput:()=>n.step,step:(e,r)=>(t.steps[e]={name:e,...r},n)};return n};var g;!function(e){e.create=e=>{let t=e.steps;e.overloads.length>0&&(t=t.map((t=>{const n=e.overloads.map((e=>{const n=e.steps[t.name];return n?{...n,discriminant:e.discriminant}:null})).filter((e=>null!==e));return{name:t.name,run:(...e)=>{const r=e[0],o=n.find((e=>r[e.discriminant[0]]===e.discriminant[1]));return o?o.run(...e):t.run(...e)},slots:{...t.slots,...n.reduce(((e,t)=>({...e,...t.slots})),{})}}})));const n=(e=>new Map(e.map((e=>[e.name,e]))))(t);return{...e,steps:t,stepsIndex:n}}}(g||(g={}));const E=async(e,t)=>{const n=$(e);return await n(t)},N=e=>{const t={type:e,input:()=>t,done:()=>g.create(e),stepWithRunnerType:()=>t.step,step:(...t)=>{const n="string"==typeof t[0]?{name:t[0],run:b,...t[1]}:{run:b,...t[0]};return N({...e,steps:[...e.steps,n]})},use:t=>N({...e,overloads:[...e.overloads,...t.type.overloads]}),overload:t=>{const n=t({create:y});return e.overloads.push(n.type),N(e)}};return t},b=e=>e.input,k=/^(?:(?<async>async)\s+)?(?:function\s+)?(?:(?<name>[A-z_0-9]+)\s*)?\((?<parameters>[^)]*)\)\s*(?:=>\s*(?<bodyExpression>[^\s{].*)|(?:=>\s*)?{(?<bodyStatement>.*)})$/s,I=/(?<destructured>\{[^}]+\})|(?<name>[A-z_][A-z_0-9]*)/gs,S=/(?<name>[A-z_][A-z_0-9]*)(?::[^},]+)?/gs;class T extends d{constructor(e){super("Interceptor must destructure the first parameter passed to it and select exactly one step.",e)}}const w="multipleParameters",x="noParameters",O="notDestructured",D="destructuredWithoutEntryHook",A="multipleDestructuredHookNames",C="invalidDestructuredHookNames",_=Symbol("resultEnvelope"),F=e=>({[_]:_,result:e});var V;!function(e){e.create=(e,t)=>(t.input=e,t)}(V||(V={}));const j=e=>({...e,currentChunk:i()}),q=async({pipeline:e,name:t,done:n,inputOriginalOrFromExtension:a,previousStepsCompleted:u,interceptorsStack:c,nextInterceptorsStack:l,asyncErrorDeferred:p,customSlots:m})=>{const f=s(`step ${t}:`);f("advance to next interceptor");const[h,...v]=c;if(!(0===v.length)&&h?.retrying&&n({type:"error",source:"user",extensionName:h.name,hookName:t,error:new d("Only the last extension can retry hooks.",{extensionsAfter:v.map((e=>({name:e.name})))})}),h){const c=s(`hook ${t}: extension ${h.name}:`),y=i();c("start");let g=!1;const E=V.create(a,(r=>{c("extension calls this hook",r);const o=r?.input??a,s={...m,...r?.using};if(y.isResolved()){if(h.retrying){if(g){c("execute branch: retry");const o=j(h);return q({pipeline:e,name:t,done:n,previousStepsCompleted:u,inputOriginalOrFromExtension:a,asyncErrorDeferred:p,interceptorsStack:[o],nextInterceptorsStack:l,customSlots:s}),o.currentChunk.promise.then((async e=>{const n=e[t];if(!n)throw Error("Hook not found in envelope: "+t);return await n({...r,input:r?.input??a})}))}return p.resolve({type:"error",source:"extension",interceptorName:h.name,hookName:t,error:new d("Only after failure can a hook be called again by a retrying extension.",{hookName:t,extensionName:h.name})}),i().promise}return p.resolve({type:"error",source:"extension",interceptorName:h.name,hookName:t,error:new d("Only a retrying extension can retry hooks.",{hookName:t,extensionsAfter:v.map((e=>({name:e.name})))})}),i().promise}{const r=j(h),i=[...l,r];return y.resolve(!0),q({pipeline:e,name:t,done:n,previousStepsCompleted:u,asyncErrorDeferred:p,inputOriginalOrFromExtension:o,interceptorsStack:v,nextInterceptorsStack:i,customSlots:s}),r.currentChunk.promise.then((e=>(e instanceof Error&&(c("received hook error"),g=!0),e)))}}));c("advance with envelope");const N={[t]:E};h.currentChunk.resolve(N),f("start race between extension returning or invoking next hook");const{branch:b,result:k}=await Promise.race([y.promise.then((e=>({branch:"hookInvoked",result:e}))).catch((e=>({branch:"hookInvokedButThrew",result:e}))),h.body.promise.then((e=>({branch:"extensionReturned",result:e}))).catch((e=>({branch:"extensionThrew",result:e})))]);switch(b){case"hookInvoked":return void c("invoked next hook (or retrying extension got error pushed through)");case"extensionReturned":return c("extension returned"),void(k===N?q({pipeline:e,name:t,done:n,previousStepsCompleted:u,inputOriginalOrFromExtension:a,asyncErrorDeferred:p,interceptorsStack:v,nextInterceptorsStack:l,customSlots:m}):n({type:"shortCircuited",result:k}));case"extensionThrew":return c("extension threw"),void n({type:"error",hookName:t,source:"extension",error:r(k),interceptorName:h.name});case"hookInvokedButThrew":return c("hook error"),void n({type:"error",hookName:t,source:"implementation",error:r(k)});default:throw o(b)}}else{f("no more interceptors to advance, run implementation");const o=e.stepsIndex.get(t);if(!o)throw new d("Implementation not found for step name "+t,{hookName:t});let i;try{const e={...o.slots,...m};i=await o.run(a,e,u)}catch(e){f("implementation error");const o=l[l.length-1];return void(o&&o.retrying?o.currentChunk.resolve(r(e)):n({type:"error",hookName:t,source:"implementation",error:r(e)}))}f("completed"),n({type:"completed",result:i,effectiveInput:a,nextExtensionsStack:l})}},P=async({pipeline:e,stepsToProcess:t,originalInputOrResult:n,interceptorsStack:r,asyncErrorDeferred:s,previousStepsCompleted:u})=>{const[c,...l]=t;if(!c){a("pipeline: ending");const e=await R({interceptorsStack:r,result:n});return a("pipeline: returning"),F(e)}a(`hook ${c.name}: start`);const p=i({strict:!1});q({pipeline:e,name:c.name,done:p.resolve,inputOriginalOrFromExtension:n,previousStepsCompleted:u,interceptorsStack:r,asyncErrorDeferred:s,customSlots:{},nextInterceptorsStack:[]});const m=await Promise.race([p.promise,s.promise]);switch(m.type){case"completed":{const{result:t,effectiveInput:n,nextExtensionsStack:r}=m,o={...u,[c.name]:{input:n}};return await P({pipeline:e,stepsToProcess:l,originalInputOrResult:t,interceptorsStack:r,previousStepsCompleted:o,asyncErrorDeferred:s})}case"shortCircuited":{a("signal: shortCircuited");const{result:e}=m;return F(e)}case"error":{if(a("signal: error"),e.config.passthroughErrorWith?.(m))return m.error;if(e.config.passthroughErrorInstanceOf.some((e=>m.error instanceof e)))return m.error;const t=s.isResolved();switch(m.source){case"extension":{const e="anonymous"===m.interceptorName?" (use named functions to improve this error message)":"";return new d(t?`There was an error in the interceptor "${m.interceptorName}"${e}.`:`There was an error in the interceptor "${m.interceptorName}"${e} while running hook "${m.hookName}".`,{hookName:m.hookName,source:m.source,interceptorName:m.interceptorName},m.error)}case"implementation":return new d(`There was an error in the core implementation of hook "${m.hookName}".`,{hookName:m.hookName,source:m.source},m.error);case"user":return m.error;default:throw o(m)}}default:throw o(m)}},R=async({interceptorsStack:e,result:t})=>{const[n,...r]=e;if(!n)return t;a(`interceptor ${n.name}: end`),n.currentChunk.resolve(t);const o=await n.body.promise;return await R({interceptorsStack:r,result:o})},$=e=>async t=>{const{initialInput:n,interceptors:r=[],retryingInterceptor:o}=t??{};var a;const s=(o?[...r,(a=o,{retrying:!0,run:a})]:r).map((t=>M(e,t))),[u,c]=(e=>{const[t,n]=(e=>{const t=[],n=[];for(const r of e)r instanceof Error?t.push(r):n.push(r);return[n,t]})(e);return[t,n.length>0?new m("One or more extensions are invalid.",{},n):null]})(s);if(c)return c;const l=i({strict:!1}),p=await P({pipeline:e,stepsToProcess:e.steps,originalInputOrResult:n,interceptorsStack:u,asyncErrorDeferred:l,previousStepsCompleted:{}});return p instanceof Error?p:(e=>({value:e}))(p.result)},M=(e,t)=>{const n=i(),r=i(),a="function"==typeof t?t:t.run,s="function"!=typeof t&&t.retrying,u=async e=>{try{const t=await a(e);r.resolve(t)}catch(e){r.reject(e)}},c=a.name||"anonymous";switch(e.config.entrypointSelectionMode){case"off":return n.promise.then(u),{name:c,entrypoint:e.steps[0]?.name,body:r,currentChunk:n};case"optional":case"required":{const t=((e,t)=>{const n=e.stepsIndex,r=(e=>{const t=(""+e).match(k)?.groups;if(!t)throw Error("Could not extract groups from function.");const n=t.bodyStatement??t.bodyExpression;if(void 0===n)throw Error("Could not extract body from function.");const r=[];if(t.parameters){const e=[...t.parameters.matchAll(I)].map((e=>{const t=e.groups?.destructured?"destructured":e.groups?.name?"name":null;switch(t){case"destructured":return{type:t,names:[...e.groups.destructured.matchAll(S)].map((e=>{const t=e.groups.name;if(void 0===t)throw Error("Could not extract name from destructured parameter.");return t}))};case"name":return{type:t,value:e.groups.name};case null:throw Error("Could not determine type of parameter.");default:throw o(t)}}));r.push(...e)}return{body:n,parameters:r}})(t);if(r.parameters.length>1)return new T({issue:w});const i=r.parameters[0];if(i){if("name"===i.type)return new T({issue:O});{if(0===i.names.length)return new T({issue:D});const e=i.names.filter((e=>n.has(e)));if(e.length>1)return new T({issue:A});const t=e[0];return t?n.get(t)||new T({issue:D}):new T({issue:C})}}return new T({issue:x})})(e,a);if(t instanceof Error)return"required"===e.config.entrypointSelectionMode?t:(n.promise.then(u),{name:c,entrypoint:e.steps[0]?.name,body:r,currentChunk:n});const i=[];for(const n of e.steps){if(n===t)break;i.push(n.name)}const l=i.map((e=>U(e)));let p=n.promise;for(const e of l)p=p.then(e);return p.then(u),{retrying:s,name:c,entryStep:t,body:r,currentChunk:n}}default:throw o(e.config.entrypointSelectionMode)}},U=e=>async t=>{const n=t[e];if(!n)throw new d("Hook not found in hook envelope",{hookName:e});return await n({input:n.input})};class L extends Error{constructor(e,t,n,r,o,i,a){super(e),this.name="GraphQLError",this.message=e,o&&(this.path=o),t&&(this.nodes=Array.isArray(t)?t:[t]),n&&(this.source=n),r&&(this.positions=r),i&&(this.originalError=i);var s=a;if(!s&&i){var u=i.extensions;u&&"object"==typeof u&&(s=u)}this.extensions=s||{}}toJSON(){return{...this,message:this.message}}toString(){return this.message}get[Symbol.toStringTag](){return"GraphQLError"}}var B,Y;function W(e){return new L(`Syntax Error: Unexpected token at ${Y} in ${e}`)}function z(e){if(e.lastIndex=Y,e.test(B))return B.slice(Y,Y=e.lastIndex)}var G=/ +(?=[^\s])/y;function J(e){for(var t=e.split("\n"),n="",r=0,o=0,i=t.length-1,a=0;t.length>a;a++)G.lastIndex=0,G.test(t[a])&&(!a||r&&G.lastIndex>=r||(r=G.lastIndex),o=o||a,i=a);for(var s=o;i>=s;s++)s!==o&&(n+="\n"),n+=t[s].slice(r).replace(/\\"""/g,'"""');return n}function H(){for(var e=0|B.charCodeAt(Y++);9===e||10===e||13===e||32===e||35===e||44===e||65279===e;e=0|B.charCodeAt(Y++))if(35===e)for(;10!==(e=B.charCodeAt(Y++))&&13!==e;);Y--}var X,Q=/[_A-Za-z]\w*/y,Z=RegExp("(?:(null|true|false)|\\$("+Q.source+')|(-?\\d+)((?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)?|("""(?:"""|(?:[\\s\\S]*?[^\\\\])"""))|("(?:"|[^\\r\\n]*?[^\\\\]"))|('+Q.source+"))","y"),K=((X=K||{})[X.Const=1]="Const",X[X.Var=2]="Var",X[X.Int=3]="Int",X[X.Float=4]="Float",X[X.BlockString=5]="BlockString",X[X.String=6]="String",X[X.Enum=7]="Enum",X),ee=/\\/;function te(e){var t,n;if(Z.lastIndex=Y,91===B.charCodeAt(Y)){Y++,H();for(var r=[];93!==B.charCodeAt(Y);)r.push(te(e));return Y++,H(),{kind:"ListValue",values:r}}if(123===B.charCodeAt(Y)){Y++,H();for(var o=[];125!==B.charCodeAt(Y);){if(null==(t=z(Q)))throw W("ObjectField");if(H(),58!==B.charCodeAt(Y++))throw W("ObjectField");H(),o.push({kind:"ObjectField",name:{kind:"Name",value:t},value:te(e)})}return Y++,H(),{kind:"ObjectValue",fields:o}}if(null!=(n=Z.exec(B))){if(Y=Z.lastIndex,H(),null!=(t=n[K.Const]))return"null"===t?{kind:"NullValue"}:{kind:"BooleanValue",value:"true"===t};if(null!=(t=n[K.Var])){if(e)throw W("Variable");return{kind:"Variable",name:{kind:"Name",value:t}}}var i;if(null!=(t=n[K.Int]))return null!=(i=n[K.Float])?{kind:"FloatValue",value:t+i}:{kind:"IntValue",value:t};if(null!=(t=n[K.BlockString]))return{kind:"StringValue",value:J(t.slice(3,-3)),block:!0};if(null!=(t=n[K.String]))return{kind:"StringValue",value:ee.test(t)?JSON.parse(t):t.slice(1,-1),block:!1};if(null!=(t=n[K.Enum]))return{kind:"EnumValue",value:t}}throw W("Value")}function ne(e){if(40===B.charCodeAt(Y)){var t,n=[];Y++,H();do{if(null==(t=z(Q)))throw W("Argument");if(H(),58!==B.charCodeAt(Y++))throw W("Argument");H(),n.push({kind:"Argument",name:{kind:"Name",value:t},value:te(e)})}while(41!==B.charCodeAt(Y));return Y++,H(),n}}function re(e){if(64===B.charCodeAt(Y)){var t,n=[];do{if(Y++,null==(t=z(Q)))throw W("Directive");H(),n.push({kind:"Directive",name:{kind:"Name",value:t},arguments:ne(e)})}while(64===B.charCodeAt(Y));return n}}function oe(){for(var e,t=0;91===B.charCodeAt(Y);)t++,Y++,H();if(null==(e=z(Q)))throw W("NamedType");H();var n={kind:"NamedType",name:{kind:"Name",value:e}};do{if(33===B.charCodeAt(Y)&&(Y++,H(),n={kind:"NonNullType",type:n}),t){if(93!==B.charCodeAt(Y++))throw W("NamedType");H(),n={kind:"ListType",type:n}}}while(t--);return n}var ie=RegExp("(?:(\\.{3})|("+Q.source+"))","y"),ae=function(e){return e[e.Spread=1]="Spread",e[e.Name=2]="Name",e}(ae||{});function se(){var e,t,n=[];do{if(ie.lastIndex=Y,null==(t=ie.exec(B)))throw W("SelectionSet");if(Y=ie.lastIndex,null!=t[ae.Spread]){H();var r=z(Q);if(null!=r&&"on"!==r)H(),n.push({kind:"FragmentSpread",name:{kind:"Name",value:r},directives:re(!1)});else{if(H(),"on"===r){if(null==(r=z(Q)))throw W("NamedType");H()}var o=re(!1);if(123!==B.charCodeAt(Y++))throw W("InlineFragment");H(),n.push({kind:"InlineFragment",typeCondition:r?{kind:"NamedType",name:{kind:"Name",value:r}}:void 0,directives:o,selectionSet:se()})}}else if(null!=(e=t[ae.Name])){var i=void 0;if(H(),58===B.charCodeAt(Y)){if(Y++,H(),i=e,null==(e=z(Q)))throw W("Field");H()}var a=ne(!1);H();var s=re(!1),u=void 0;123===B.charCodeAt(Y)&&(Y++,H(),u=se()),n.push({kind:"Field",alias:i?{kind:"Name",value:i}:void 0,name:{kind:"Name",value:e},arguments:a,directives:s,selectionSet:u})}}while(125!==B.charCodeAt(Y));return Y++,H(),{kind:"SelectionSet",selections:n}}function ue(){var e,t;if(null==(e=z(Q)))throw W("FragmentDefinition");if(H(),"on"!==z(Q))throw W("FragmentDefinition");if(H(),null==(t=z(Q)))throw W("FragmentDefinition");H();var n=re(!1);if(123!==B.charCodeAt(Y++))throw W("FragmentDefinition");return H(),{kind:"FragmentDefinition",name:{kind:"Name",value:e},typeCondition:{kind:"NamedType",name:{kind:"Name",value:t}},directives:n,selectionSet:se()}}var ce=/(?:query|mutation|subscription|fragment)/y;function le(e){var t,n,r;if(e&&(H(),t=z(Q),n=function(){if(H(),40===B.charCodeAt(Y)){var e,t=[];Y++,H();do{if(36!==B.charCodeAt(Y++))throw W("Variable");if(null==(e=z(Q)))throw W("Variable");if(H(),58!==B.charCodeAt(Y++))throw W("VariableDefinition");H();var n=oe(),r=void 0;61===B.charCodeAt(Y)&&(Y++,H(),r=te(!0)),H(),t.push({kind:"VariableDefinition",variable:{kind:"Variable",name:{kind:"Name",value:e}},type:n,defaultValue:r,directives:re(!0)})}while(41!==B.charCodeAt(Y));return Y++,H(),t}}(),r=re(!1)),123===B.charCodeAt(Y))return Y++,H(),{kind:"OperationDefinition",operation:e||"query",name:t?{kind:"Name",value:t}:void 0,variableDefinitions:n,directives:r,selectionSet:se()}}const pe="OperationDefinition",de="NamedType",me="query",fe="mutation",he=e=>({kind:"Name",...e}),ve=e=>({kind:"Argument",...e}),ye=e=>"object"==typeof e&&null!==e&&"kind"in e&&e.kind===pe,ge=e=>({kind:"SelectionSet",...e}),Ee=e=>({kind:de,...e}),Ne=e=>({kind:"Field",...e}),be=e=>({kind:"EnumValue",...e}),ke=e=>({kind:"Variable",...e}),Ie=e=>({kind:"ListValue",...e}),Se=e=>e.kind===de?e:Se(e.type),Te=e=>{for(const t of e.query.definitions){const n=ye(t)?t:null;if(!e.operationName)return n;if(n?.name?.value===e.operationName)return n}return null},we=RegExp(`^\\b(${Object.values(Object.freeze({__proto__:null,MUTATION:fe,QUERY:me,SUBSCRIPTION:"subscription"})).join("|")})\\b`),xe=e=>{const t=e;return c(t)?function(e){return Y=0,function(e){var t,n;H();var r,o=[];do{if("fragment"===(t=z(ce)))H(),o.push(ue());else{if(null==(n=le(t)))throw W("Document");o.push(n)}}while(e.length>Y);return{kind:"Document",definitions:o,set loc(e){r=e},get loc(){return r||(r={start:0,end:e.length,startToken:void 0,endToken:void 0,source:{body:e,name:"graphql.web",locationOffset:{line:1,column:1}}}),r}}}(B="string"==typeof e.body?e.body:e)}(t):t},Oe=(e,t)=>{const n="object"==typeof t.output?.envelope?{enabled:!0,...t.output.envelope}:"boolean"==typeof t.output?.envelope?{enabled:t.output.envelope}:void 0,r={name:t.name??e?.name??ft,schemaMap:t.schemaMap??e.schemaMap,output:{defaults:{errorChannel:t.output?.defaults?.errorChannel??e.output.defaults.errorChannel},envelope:{enabled:n?.enabled??e.output.envelope.enabled,errors:{execution:n?.errors?.execution??e.output.envelope.errors.execution,other:n?.errors?.other??e.output.envelope.errors.other,schema:n?.errors?.schema??e.output.envelope.errors.schema}},errors:{execution:t.output?.errors?.execution??e.output.errors.execution,other:t.output?.errors?.other??e.output.errors.other,schema:t.output?.errors?.schema??e.output.errors.schema}}};return ht.withTypeLevel({...e,...r})},De=e=>{const t=xe(e.query);if("operation"in e){const n=Te({...e,query:xe(e.query)});return{...e,operation:n,query:t}}return{...e,query:t}},Ae=e=>{if(void 0===e)return;if(null===e)return null;if("object"!=typeof e)return e;if(Array.isArray(e))return e.map(Ae);if(!function(e){if(!e||"object"!=typeof e)return!1;const t=Object.getPrototypeOf(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t))&&"[object Object]"==={}.toString.call(e)}(e))return e;const t={};for(const n in e){const r=n.replace(/^\$/,""),o=Ae(e[n]);t[r]=o}return t},Ce=(e,t)=>_e(e,t),_e=(e,t)=>{if(e===Fe)return{type:"Arguments",arguments:t};const n=He(e);if(n){const r=Je[n];if(!r)throw Error(`Unknown directive ${e}.`);return{type:"Directive",name:n,arguments:void 0===t?null:{input:t,parsed:r.normalizeArguments(t)}}}if(e===ot)return{type:"ScalarsWildcard"};if(Ze(t))return{type:"Indicator",name:e,select:Qe(t)};const r=tt(e);if(r){const e=et(t);return{type:"InlineFragment",typeCondition:r.typeCondition,selectionSets:e}}if(nt(t))return{type:"Alias",name:e,aliases:rt(t)};if("object"==typeof t&&null!==t)return{type:"SelectionSet",name:e,selectionSet:t};throw Error(`Unknown selection at key ${e}.`)},Fe="$",Ve=e=>e.startsWith("$"),je=(e,t)=>({kind:"Scalar",name:e,codec:t}),qe={encode:e=>e,decode:e=>e},Pe={encode:e=>e,decode:e=>e},Re=je("String",qe),$e=je("Boolean",Pe);var Me;!function(e){e.empty={map:{}}}(Me||(Me={}));const Ue=(e,t)=>e[t]||Re,Le=(e,t)=>null===t?null:Array.isArray(t)?t.map((t=>Le(e,t))):e(t),Be=e=>"object"==typeof e&&null!==e&&"codec"in e&&"object"==typeof e.codec,Ye={include:{name:"include",arguments:{if:{name:"if",type:$e}}},skip:{name:"skip",arguments:{if:{name:"if",type:$e}}}},We={name:"include",type:Ye.include,normalizeArguments:e=>"boolean"==typeof e?ze(e):((e,t)=>{const n={...Ge};for(const e in t)void 0!==t[e]&&(n[e]=t[e]);return n})(0,e)},ze=e=>({if:e}),Ge={if:!0},Je={include:We,skip:{name:"skip",type:Ye.skip,normalizeArguments:e=>({if:"boolean"==typeof e?e:void 0===e.if||e.if})}},He=e=>e.startsWith("$")?e.slice(1):null,Xe="__default__",Qe=e=>true===e,Ze=e=>Qe(e)||(e=>false===e||undefined===e)(e),Ke=/^___(?:on_(?<typeCondition>.+))?$/,et=e=>Array.isArray(e)?e:[e],tt=e=>{const t=e.match(Ke);return t?{typeCondition:t.groups?.typeCondition??null}:null},nt=e=>Array.isArray(e)&&(2===e.length&&"string"==typeof e[0]||nt(e[0])),rt=e=>(e=>"string"==typeof e[0])(e)?[e]:e,ot="$scalars",it=e=>!!e&&!c(e)&&"k"in e&&"enum"===e.k,at=e=>c(e),st=Be,ut=e=>Be(e)||at(e),ct=e=>{const{parentContext:t,value:n,sddmNode:r,documentPart:o,scalars:i}=e;var a;if(null!==n)if(Array.isArray(n))n.forEach(((e,t)=>{ct({parentContext:{type:"list",object:n,index:t},value:e,sddmNode:r,documentPart:o,scalars:i})}));else if("object"==typeof n){if(!(a=r)||c(a)||!("f"in a))return;const e=n;for(const[t,n]of Object.entries(e)){const a=lt(o,t),s=r.f[a?.name.value??t];s?.nt&&ct({parentContext:{type:"object",object:e,fieldName:t},value:n,sddmNode:s.nt,documentPart:a?.selectionSet??null,scalars:i})}}else{if(!t)return;if(st(r)){const e=Le(r.codec.decode,n);"object"===t.type?t.object[t.fieldName]=e:t.object[t.index]=e}else if(at(r)){const e=Ue(i,r),o=Le(e.codec.decode,n);"object"===t.type?t.object[t.fieldName]=o:t.object[t.index]=o}}},lt=(e,n)=>{if(!e)return null;for(const r of e.selections){if(r.kind===t.FIELD&&(r.alias?.value??r.name.value)===n)return r;if(r.kind===t.INLINE_FRAGMENT){const e=lt(r.selectionSet,n);if(null!==e)return e}}return null},pt=(e,t,n,r,o)=>{if(at(r)){const i=Ue(o,r);e[t]=Le(i.codec.encode,n)}else{var i;if(st(r))e[t]=Le(r.codec.encode,n);else if((i=r)&&!c(i)&&"f"in i)for(const e of r.fcs??[]){if("object"!=typeof n||null===n)continue;const t=n[e];if(void 0===t)continue;const i=r.f?.[e];i?.nt&&pt(n,e,t,i.nt,o)}}},dt=(e=>{const t=(e=>({passthroughErrorInstanceOf:e?.passthroughErrorInstanceOf??[],passthroughErrorWith:e?.passthroughErrorWith,entrypointSelectionMode:e?.entrypointSelectionMode??"required"}))(e);return N({steps:[],config:t,overloads:[]})})({passthroughErrorWith:e=>"exchange"===e.hookName&&(e=>e instanceof DOMException&&"AbortError"===e.name||e instanceof Error&&e.message.startsWith("AbortError:"))(e.error)}).input().step("encode",{run:e=>{const t=e.state.schemaMap,n=e.state.scalars.map;if(t){const r=De(e.request);e.request.query=r.query,(({sddm:e,request:t,scalars:n})=>{const r=t.operation.variableDefinitions;if(!r)return;const o=new Map(r.map((e=>[e.variable.name.value,e]))),i=t.variables??{};for(const t in i){const r=o.get(t);if(!r)continue;const a=i[t];if(void 0===a)continue;const s=Se(r.type),u=e.types[s.name.value];u&&pt(i,t,a,u,n)}})({sddm:t,scalars:n,request:r})}return e.request.variables=Ae(e.request.variables),e}}).step("pack").step("exchange").step("unpack").step("decode",{run:(e,t,n)=>(e.state.schemaMap&&!(!e.result.data&&(e.result.errors?.length??0)>0)&&(({request:e,data:t,sddm:n,scalars:r})=>{const o=n.operations[e.operation.operation];o&&t&&ct({parentContext:null,value:t,sddmNode:o,documentPart:e.operation.selectionSet,scalars:r})})({sddm:e.state.schemaMap,request:De(n.pack.input.request),data:e.result.data,scalars:e.state.scalars.map}),"http"===e.transportType?{...e.result,response:e.response}:e.result)}).type;var mt;!function(e){(e.States||(e.States={})).empty={registry:{},configurations:{},current:null}}(mt||(mt={}));const ft="default";var ht;!function(e){e.withTypeLevel=e=>e,(e.States||(e.States={})).empty={name:ft,requestPipelineDefinition:dt,transports:mt.States.empty,checkPreflight:!0,input:{},output:h,schemaMap:null,extensions:[],scalars:Me.empty}}(ht||(ht={}));const vt=e=>{if(e.it){const t=1===e.it[0]?"!":"",n=gt(e);return yt(e.it[1],n)+t}return gt(e)},yt=(e,t)=>{if(!e)return t;const n=1===e[0]?"!":"";return`[${yt(e[1],t)}${n}]`},gt=e=>{if(st(e.nt))return e.nt.name;if(at(e.nt))return e.nt;if(e.nt?.n)return e.nt.n;throw Error("Unknown sddm node: "+e)},Et=(e,t,n)=>{if(ut(t?.nt)){const r=st(t.nt)?t.nt:Ue(e.scalars,t.nt);return Nt(e,r,n)}if(it(t?.nt))return be({value:n+""});if(null===n)return{kind:"NullValue"};if(Array.isArray(n))return Ie({values:n.map((n=>Et(e,t,n)))});if("object"==typeof n){const o=t?.nt;return r={fields:Object.entries(n).map((([t,n])=>{return r={name:he({value:t}),value:Et(e,o?.f?.[t],n)},{kind:"ObjectField",...r};var r}))},{kind:"ObjectValue",...r}}var r,o,i,a;if("string"==typeof n)return e.value.isEnum?be({value:n+""}):(o={value:n},{kind:"StringValue",...o});if("boolean"==typeof n)return i={value:n},{kind:"BooleanValue",...i};if("number"==typeof n)return a={value:n+""},{kind:"FloatValue",...a};throw Error("Unsupported value: "+n)},Nt=(e,t,n)=>{if(null===n)return{kind:"NullValue"};if(Array.isArray(n))return Ie({values:n.map((n=>Nt(e,t,n)))});const r=t.codec.encode(n);return Et(e,void 0,r)},bt=(e,t,n,r)=>{switch(n.type){case"Directive":{const t=((e,t,n)=>{if(null===n.arguments)return null;const r=[];for(const o in n.arguments.parsed){const i=n.arguments.parsed[o],a=t?.[o];let s;if(e.variables.enabled&&a)s=e.variables.capture({name:o,value:i,sddmArgument:a});else{const t=he({value:o}),n=Et({...e,value:{isEnum:!1}},a,i);s=ve({name:t,value:n})}r.push(s)}return(e=>({kind:"Directive",...e}))({name:he({value:n.name}),arguments:r})})(e,e.sddm?.directives[n.name],n);t&&r.directives.push(t);break}default:r.selections.push(...St(e,t,n))}},kt=(e,t,n)=>{const r={...e,value:{isEnum:Ve(n.name)}},o=Et(r,t,n.value),i=he({value:n.name.replace(/^\$/g,"")});return ve({name:i,value:o})},It=(e,t,n)=>{const r=((e,t)=>_e(e,t))(n.name,n.value),o=n.alias?he({value:n.alias}):void 0;if("Indicator"===r.type)return r.select?Ne({name:he({value:n.name}),alias:o}):null;const i=[],a=[],s=[];for(const n in r.selectionSet){const o=_e(n,r.selectionSet[n]);if("Arguments"!==o.type){if(ut(t?.nt)||(u=t?.nt,u&&!c(u)&&"a"in u)||it(t?.nt))throw Error("schema map scalar on non-scalar graffle selection.");bt(e,t?.nt,o,{directives:a,selections:s})}else{const n=t?.a;for(const t in o.arguments){const r=t.replace(/^\$/,""),a=n?.[r],s=o.arguments[t];if(e.variables.enabled&&a){const t=e.variables.capture({name:r,value:s,sddmArgument:a});i.push(t)}else{const n=kt(e,a,{name:t,value:s});i.push(n)}}}}var u;const l=0===s.length?void 0:ge({selections:s});return Ne({name:he({value:n.name}),alias:o,arguments:i,directives:a,selectionSet:l})},St=(e,t,n)=>{switch(n.type){case"Indicator":return n.select?[Ne({name:he({value:n.name})})]:[];case"InlineFragment":return((e,t,n)=>n.selectionSets.map((r=>((e,t,n)=>{const r=n.typeCondition?Ee({name:he({value:n.typeCondition})}):void 0,o=[],i=[];for(const r in n.selectionSet){const a=Ce(r,n.selectionSet[r]);bt(e,t,a,{directives:o,selections:i})}return(e=>({kind:"InlineFragment",...e}))({typeCondition:r,directives:o,selectionSet:ge({selections:i})})})(e,t,{selectionSet:r,typeCondition:n.typeCondition}))))(e,t,n);case"Alias":{const r=t?.f[n.name];return n.aliases.map((t=>It(e,r,{name:n.name,alias:t[0],value:t[1]}))).filter(l)}case"SelectionSet":{const r=t?.f[n.name];return[It(e,r,{alias:null,name:n.name,value:n.selectionSet})].filter(l)}case"ScalarsWildcard":throw Error("todo");default:throw o(n)}},Tt=(e,t,n)=>{const r=(e=>{const t={sddm:e?.sddm??void 0,scalars:e?.scalars??{},variables:{enabled:e?.operationVariables??!0,capture:e=>{let n=e.name,r=2;for(;t.variables.data.find((e=>e.name===n));)n=`${e.name}_${r+""}`,r++;return t.variables.data.push({name:n,typeName:vt(e.sddmArgument),value:e.value}),ve({name:he({value:e.name}),value:ke({name:he({value:n})})})},data:[]}};return t})(n),o=t.name?he({value:t.name}):void 0,i=((e,t,n)=>ge({selections:Object.entries(n).map((([e,t])=>((e,t)=>_e(e,t))(e,t))).flatMap((n=>St(e,t,n)))}))(r,e,t.selectionSet),a=r.variables.data.map((e=>{return t={variable:ke({name:he({value:e.name})}),type:Ee({name:he({value:e.typeName})})},{kind:"VariableDefinition",...t};var t})),s=(e=>({kind:pe,...e}))({operation:t.type,name:o,selectionSet:i,variableDefinitions:a});return{operation:s,variables:Object.fromEntries(r.variables.data.map((e=>[e.name,e.value])))}},wt=(t,n)=>({document:xt(n),query:Ot(n,e.QUERY),mutation:Ot(n,e.MUTATION)}),xt=e=>t=>{const n=(e=>{const t=Object.entries(e.query??{}).map((([e,t])=>[e,{name:e,type:me,selectionSet:t}])),n=Object.entries(e.mutation??{}).map((([e,t])=>[e,{name:e,type:fe,selectionSet:t}])),r=[...t,...n],o=t.filter((([e,t])=>n.some((([e,n])=>n.name===t.name))));if(o.length>0)throw{errors:[Error(`Document has multiple uses of operation name(s): ${o.join(", ")}.`)]};const i=r.length>1;if(0===r.length)throw{errors:[Error("Document has no operations.")]};return{operations:Object.fromEntries(r),facts:{hasMultipleOperations:i}}})(t);return{run:async t=>await Ct(e,n,t)}},Ot=(e,t)=>new Proxy({},{get:(n,r)=>{if((e=>"symbol"==typeof e)(r))throw Error("Symbols not supported.");if(r.startsWith("$batch"))return async n=>At(e,t,n);{const n=r;return r=>Dt(e,t,n,r)}}}),Dt=async(e,t,n,r)=>{const o=await At(e,t,{[n]:r??{}});return o instanceof Error||e.output.envelope.enabled?o:o[n]},At=async(e,t,n)=>Ct(e,((e,t)=>({operations:{[Xe]:{name:null,type:e,selectionSet:t}},facts:{hasMultipleOperations:!1}}))(t,n)),Ct=async(e,t,n)=>{if(!e.transports.current)throw Error("No transport configured.");const r=_t(((e,t)=>{const n=Object.values(e.operations).map((e=>{const n=t?.sddm?.operations[e.type];return Tt(n,e,t)}));var r;return{document:(r={definitions:n.map((e=>e.operation))},{kind:"Document",...r}),operationsVariables:Object.fromEntries(n.map((e=>[e.operation.name?.value??"$default",e.variables])))}})(t,{sddm:e.schemaMap,scalars:e.scalars.map}),n),o={transportType:e.transports.current,...e.transports.configurations[e.transports.current],state:e,request:r},i=g.create(e.requestPipelineDefinition),a=await E(i,{initialInput:o,interceptors:e.extensions.filter((e=>void 0!==e.onRequest)).map((e=>e.onRequest))});return v(e,a)},_t=({document:e,operationsVariables:t},n)=>{const r=n?t[n]:Object.values(t)[0],o=Te({query:e,operationName:n});if(!o)throw Error(`Unknown operation named "${n+""}".`);return{operationName:n,operation:o,query:e,variables:r}};var Ft;!function(e){e.create=p}(Ft||(Ft={}));const Vt=e=>{const t=t=>{const n=e.normalizeConfig?.(t)??{},r=e.create({config:n}),o=r.builder?.(Ft.create),i=r.transport?.((e=>y({discriminant:["transportType",e]})))?.type;return{name:e.name,config:n,onRequest:r.onRequest,builder:o,transport:i?{name:i.discriminant[1],config:i.input,configInit:void 0,configDefaults:i.inputDefaults,requestPipelineOverload:i}:void 0,typeHooks:{onRequestDocumentRootType:[],onRequestResult:[]}}};return t.info={name:e.name},t},jt=(e,t)=>({anyware:n=>e({...t,extensions:[...t.extensions,Vt({name:"InlineAnyware",create:()=>({onRequest:n})})()]})}),qt=e=>({document:(e=>{return Array.isArray(t=e[0])&&"raw"in t&&void 0!==t.raw;var t})(e)?(e=>{const[t,...n]=e;return t.reduce(((e,t,r)=>`${e}${t}${r in n?n[r]+"":""}`),"")})(e):e[0]}),Pt=(e,t)=>({gql:(...e)=>{const{document:n}=qt(e);return{send:async(...e)=>{if(!t.transports.current)throw Error("No transport selected");const{operationName:r,variables:o}=(e=>({operationName:c(e[0])?e[0]:void 0,variables:c(e[0])?e[1]:e[0]}))(e),i=(e=>{const{operationName:t,query:n}=e,r=n;if(!c(r)){const e=Te({query:r,operationName:t});if(e)return e.operation;throw Error("Could not parse operation type from document.")}const o=r.split(/[{}\n]+/).map((e=>e.trim())).map((e=>{const t=e.match(we);return t?{line:e,operationType:t[0]}:null})).filter((e=>null!==e));if(o.length>1&&!e.operationName)return null;if(0===o.length&&e.operationName)return null;if(0===o.length)return me;const i=t?o.find((e=>e.line.includes(t))):o[0];return i?i.operationType:null})({query:n,variables:o,operationName:r});if(!i)throw Error("Could not get operation type");const a={transportType:t.transports.current,...t.transports.configurations[t.transports.current],state:t,request:{operation:i,query:n,variables:o,operationName:r}},s=g.create(t.requestPipelineDefinition),u=await E(s,{initialInput:a,interceptors:t.extensions.filter((e=>void 0!==e.onRequest)).map((e=>e.onRequest))});return v(t,u)}}}}),Rt=(e,t)=>({scalar:(...n)=>{const r=Be(n[0])?n[0]:je(n[0],n[1]);return e({...t,scalars:{...t.scalars,map:{...t.scalars.map,[r.name]:r}}})}}),$t=(e,t)=>({transport:(...n)=>{const r="string"==typeof n[0]?n[0]:t.transports.current,o=("string"==typeof n[0]?n[1]:n[0])??{};if(!r)throw Error("No transport is currently set.");const i=Mt(t,r,o);return e(i)}}),Mt=(e,t,n)=>{const r={...e.transports.configurations[t]??{},...n};return"http"===t&&n.headers&&(r.headers={...e.transports.configurations[t]?.headers,...n.headers}),{...e,transports:{...e.transports,current:t,configurations:{...e.transports.configurations,[t]:r}}}},Ut=(e,t)=>({use:n=>e(((e,t)=>{const n={...e,extensions:[...e.extensions,t]};if(t.transport){if(n.requestPipelineDefinition={...e.requestPipelineDefinition,overloads:[...e.requestPipelineDefinition.overloads,t.transport.requestPipelineOverload]},n.transports={current:e.transports.current,registry:{...e.transports.registry},configurations:{...e.transports.configurations}},void 0!==n.transports.registry[t.transport.name])throw Error(`Transport "${t.transport.name}" is already registered.`);null===n.transports.current&&(n.transports.current=t.transport.name),n.transports.registry[t.transport.name]=t.transport,n.transports.configurations[t.transport.name]={...t.transport.configDefaults,...t.transport.config}}return n})(t,n))}),Lt=e=>{const t={_:e,...(n=Lt,r=e,{with:e=>n(Oe(r,e))}),...$t(Lt,e),...Pt(0,e),...Ut(Lt,e),...jt(Lt,e),...Rt(Lt,e)};var n,r;return Object.assign(t,{...wt(0,e)}),u(t,(({path:n,property:r})=>{const o=e.extensions.map((e=>e.builder)).filter((e=>void 0!==e));for(const e of o){const o=e({client:t,path:n,property:r});if(void 0!==o)return o}}))},Bt=(()=>{const e=Oe(ht.States.empty,{});return Lt(e)})();console.log(Bt);
